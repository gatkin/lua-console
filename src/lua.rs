#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use std::ffi::{CStr, CString};
use std::os::raw::{c_char, c_int, c_void, c_longlong};
use std::ptr;

use libc;

/// Provides a safe handle to the lua_State structure used in the
/// Lua C API.
pub struct LuaState {
    state: *mut lua_State,
    io: *mut LuaIOContainer,
}

/// Trait used to respond to output generated by an executing Lua chunk.
pub trait LuaIO {
    fn on_print(&mut self, values: Vec<String>);
}

/// Container to hold a reference to a LuaIO trait object. Since trait objects are "fat"
/// pointers, they cannot be cast between raw C pointers. The IO trait object is used
/// in standard Lua functions that are defined in Rust so that output can be redirected.
/// The trait objects are storead as light userdata objects and made available to the
/// standard output functions as an upvalue for that function.
struct LuaIOContainer {
    io: Box<LuaIO>,
}

impl LuaState {
    /// Creates and configures a new Lua state that can be used to execute
    /// Lua chunks
    pub fn new(io: Box<LuaIO>) -> LuaState {
        let state = unsafe{ luaL_newstate() };
        let io_container = Box::into_raw(Box::new(LuaIOContainer{ io }));

        unsafe{ luaL_openlibs(state) };
        unsafe{ LuaState::register_print(state, io_container as *mut c_void); }

        LuaState{
            state,
            io: io_container,
        }
    }

    /// Executes the given Lua chunk. Returns all values pushed onto the stack
    /// by the chunk converted to strings.
    pub fn execute_chunk(&mut self, chunk: &str) -> i32 {
        unsafe {
            let mut rcode = self.load_string(chunk);
            if rcode == LUA_OK {
                rcode = lua_pcall(self.state, 0, LUA_MULTRET, 0);
            }

            if rcode == LUA_OK {
                print_stack(self.state);
            }

            rcode
        }
    }

    fn load_string(&mut self, chunk: &str) -> i32 {
        let mut rcode = try_add_return(self.state, chunk);
        if rcode != LUA_OK {
            rcode = load_string(self.state, chunk);
        }

        rcode
    }

    unsafe fn register_print(L: *mut lua_State, io_userdata: *mut c_void) {
        lua_pushglobaltable(L);
        
        // Make a reference to the IO writer available as an up value in the
        // print function.
        lua_pushlightuserdata(L, io_userdata);
        lua_pushcclosure(L, print, 1);

        // Set the "print" value in the global table to our custom print function
        let name = CString::new("print").unwrap();
        lua_setfield(L, -2, name.as_ptr());

        lua_pop(L, 1); // Pop the global table from the stack
    }
}

impl Drop for LuaState {
    fn drop(&mut self) {
        unsafe {
            lua_close(self.state);
            let _io = Box::from_raw(self.io);
        }
    }
}

const LUAI_MAXSTACK: c_int = 1000000;
const LUA_MULTRET: c_int = -1;
const LUA_OK: c_int = 0;
const LUA_REGISTRYINDEX: c_int = (-LUAI_MAXSTACK) - 1000;
const LUA_RIDX_GLOBALS: c_int = 2;

type lua_CFunction = unsafe extern "C" fn(L: *mut lua_State) -> c_int;
type lua_Integer = c_longlong;
type lua_KContext = *mut c_void;
type lua_KFunction = *mut c_void;
type lua_State = *mut c_void;

/// Compiles, but does not execute, the given chunk.
fn load_string(L: *mut lua_State, chunk: &str) -> c_int {
    unsafe {
        luaL_loadbuffer(
            L,
            chunk.as_ptr() as *const c_char,
            chunk.len() as libc::size_t,
            ptr::null(),
        )
    }
}

/// Prints all values on left on the top of the stack
unsafe fn print_stack(L: *mut lua_State) {
    let num_stack_values = lua_gettop(L);

    if num_stack_values > 0 {
        let print_fn_name = CString::new("print").unwrap();
        lua_getglobal(L, print_fn_name.as_ptr());
        lua_insert(L, 1); // Send the print function to the bottom of the stack
        
        // Call the print function with all values on the stacks as its arguments
        lua_pcall(L, num_stack_values, LUA_MULTRET, 0);
    }
}

/// Custom print function that replaces the default Lua print function.
unsafe extern "C" fn print(L: *mut lua_State) -> c_int {
    // Load the printer we saved in the closure
    let io_idx = lua_upvalueindex(1);
    let raw_io_ptr = lua_touserdata(L, io_idx);
    let io = &mut *(raw_io_ptr as *mut LuaIOContainer);
    
    let arg_count = lua_gettop(L);
    let print_name = CString::new("tostring").unwrap();
    lua_getglobal(L, print_name.as_ptr());

    let mut values = Vec::with_capacity(arg_count as usize);
    for i in 1 .. arg_count + 1 {
        lua_pushvalue(L, -1); // Push the print function to the top of the stack
        lua_pushvalue(L, i); // Push the ith argument to us to the top
        lua_call(L, 1, 1);

        let raw_value = lua_tolstring(L, -1, ptr::null_mut());
        let value = String::from(CStr::from_ptr(raw_value).to_str().unwrap());
        values.push(value);

        lua_pop(L, 1); // Remove the value from the stack
    }

    io.io.on_print(values);

    LUA_OK
}

/// Attempts to turn the given chunk into an expression by adding a "return" in
/// front of it. Returns the status code from compiling the chunk with a return
fn try_add_return(L: *mut lua_State, chunk: &str) -> c_int {
    let mut with_return = String::from("return ");
    with_return.push_str(chunk);
    let rcode = load_string(L, &with_return);

    if LUA_OK != rcode {
        unsafe { lua_pop(L, 1); } // Pop the result from load buffer
    }

    rcode
}

#[link(name = "lua5.3")]
extern "C" {
    fn lua_callk
        (
        L: *mut lua_State,
        n_args: c_int,
        nresults: c_int,
        ctx: lua_KContext,
        k: lua_KFunction
        );

    fn lua_close(L: *mut lua_State);

    fn lua_getglobal(L: *mut lua_State, name: *const c_char) -> c_int;

    fn lua_gettop(L: *mut lua_State) -> c_int;

    fn lua_rotate(L: *mut lua_State, index: c_int, n: c_int);

    fn lua_pcallk
        (
        L: *mut lua_State,
        n_args: c_int,
        nresults: c_int,
        errfunc: c_int,
        ctx: lua_KContext,
        k: lua_KFunction
        ) -> c_int;

    fn lua_pushcclosure(L: *mut lua_State, f: lua_CFunction, n: c_int);

    fn lua_pushlightuserdata(L: *mut lua_State, p: *mut c_void);

    fn lua_pushvalue(L: *mut lua_State, idx: c_int);

    fn lua_rawgeti(L: *mut lua_State, idx: c_int, n: lua_Integer) -> c_int;

    fn lua_setfield(L: *mut lua_State, idx: c_int, k: *const c_char);

    fn lua_settop(L: *mut lua_State, idx: c_int);

    fn lua_tolstring(L: *mut lua_State, idx: c_int, len: *mut usize) -> *const c_char;

    fn lua_touserdata(L: *mut lua_State, idx: c_int) -> *mut c_void;

    fn luaL_loadbufferx
        (
        L: *mut lua_State,
        buff: *const c_char,
        size: libc::size_t,
        name: *const c_char,
        mode: *const c_char
        ) -> c_int;

    fn luaL_newstate() -> *mut lua_State;

    fn luaL_openlibs(L: *mut lua_State);
}

unsafe fn lua_call(L: *mut lua_State, n: c_int, r: c_int) {
    lua_callk(L, n, r, ptr::null_mut(), ptr::null_mut());
}

unsafe fn lua_insert(L: *mut lua_State, idx: c_int) {
    lua_rotate(L, idx, 1);
}

unsafe fn lua_pcall(L: *mut lua_State, nargs: c_int, nresults: c_int, errfunc: c_int) -> c_int {
    lua_pcallk(L, nargs, nresults, errfunc, ptr::null_mut(), ptr::null_mut())
}

unsafe fn lua_pop(L: *mut lua_State, n: c_int) {
    lua_settop(L, (-n) - 1);
}

unsafe fn lua_pushglobaltable(L: *mut lua_State) {
    lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS as lua_Integer);
}

fn lua_upvalueindex(i: c_int) -> c_int {
    LUA_REGISTRYINDEX - i
}

unsafe fn luaL_loadbuffer
    (
    L: *mut lua_State,
    buff: *const c_char,
    size: libc::size_t,
    name: *const c_char
    ) -> c_int
{
    luaL_loadbufferx(
        L,
        buff,
        size,
        name,
        ptr::null()
    )
}